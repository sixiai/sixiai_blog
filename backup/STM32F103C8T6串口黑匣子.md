# SD卡数据记录系统 - 完整总结 

## 一、系统功能

```
┌─────────────────────────────────────────────────────────┐
│  串口发送 "$new" → 新建 data00.txt → 开始记录数据        │
│  串口发送 "$new" → 新建 data01.txt → 继续记录数据        │
│  串口发送 "$new" → 新建 data02.txt → ...                │
│                                                         │
│  定时同步数据到SD卡，防止断电丢失                         │
└─────────────────────────────────────────────────────────┘
```

## 二、文件结构

```
Project/
├── Core/Inc/
│   ├── sd_spi.h			     ← SD初始化驱动
│   ├── uart_driver.h      ← 串口驱动
│   └── sd_logger.h        ← SD记录器
├── Core/Src/
│   ├── main.c             ← 主程序
│   ├── sd_spi.c			     ← SD初始化驱动
│   ├── uart_driver.c      ← 串口驱动
│   ├── sd_logger.c        ← SD记录器
│   └── stm32f1xx_it.c     ← 中断处理
└── FATFS/                 
│   ├── user_diskio.c			 ← FatFs文件系统挂载
```

## 三、核心代码

#### 3.1 sd_spi.h

```c
/* sd_spi.h */
#ifndef __SD_SPI_H
#define __SD_SPI_H

#include "main.h"
#include "spi.h"

/* SD卡类型定义 */
#define SD_TYPE_ERR     0x00
#define SD_TYPE_MMC     0x01
#define SD_TYPE_V1      0x02
#define SD_TYPE_V2      0x04
#define SD_TYPE_V2HC    0x06

/* SD卡指令 */
#define CMD0    0       // 复位
#define CMD1    1       // 初始化
#define CMD8    8       // 检查电压范围
#define CMD9    9       // 读CSD
#define CMD10   10      // 读CID
#define CMD12   12      // 停止传输
#define CMD16   16      // 设置块大小
#define CMD17   17      // 读单块
#define CMD18   18      // 读多块
#define CMD23   23      // 预擦除
#define CMD24   24      // 写单块
#define CMD25   25      // 写多块
#define CMD41   41      // 初始化(ACMD)
#define CMD55   55      // APP命令前缀
#define CMD58   58      // 读OCR

/* 函数声明 */
uint8_t SD_Init(void);
uint8_t SD_ReadDisk(uint8_t *buf, uint32_t sector, uint8_t cnt);
uint8_t SD_WriteDisk(uint8_t *buf, uint32_t sector, uint8_t cnt);
uint32_t SD_GetSectorCount(void);

extern uint8_t SD_Type;

#endif

```

#### 3.2 sd_spi.c

```c
/* sd_spi.c */
#include "sd_spi.h"

uint8_t SD_Type = 0;

/* CS引脚控制 */
#define SD_CS_LOW()     HAL_GPIO_WritePin(CD_CS_GPIO_Port, CD_CS_Pin, GPIO_PIN_RESET)
#define SD_CS_HIGH()    HAL_GPIO_WritePin(CD_CS_GPIO_Port, CD_CS_Pin, GPIO_PIN_SET)

/* SPI读写一个字节 */
static uint8_t SD_SPI_ReadWriteByte(uint8_t data)
{
    uint8_t rxData;
    HAL_SPI_TransmitReceive(&hspi1, &data, &rxData, 1, 100);
    return rxData;
}

/* 设置SPI速度 */
static void SD_SPI_SetSpeed(uint8_t speed)
{
    __HAL_SPI_DISABLE(&hspi1);
    if(speed == 0) {
        hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256; // 低速
    } else {
        hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;   // 高速
    }
    HAL_SPI_Init(&hspi1);
    __HAL_SPI_ENABLE(&hspi1);
}

/* 等待SD卡就绪 */
static uint8_t SD_WaitReady(void)
{
    uint32_t t = 0;
    do {
        if(SD_SPI_ReadWriteByte(0xFF) == 0xFF) return 0;
        t++;
    } while(t < 0xFFFFFF);
    return 1;
}

/* 发送命令 */
static uint8_t SD_SendCmd(uint8_t cmd, uint32_t arg, uint8_t crc)
{
    uint8_t r1;
    uint8_t retry = 0;
    
    SD_CS_HIGH();
    SD_SPI_ReadWriteByte(0xFF);
    SD_CS_LOW();
    
    if(SD_WaitReady()) return 0xFF;
    
    SD_SPI_ReadWriteByte(cmd | 0x40);
    SD_SPI_ReadWriteByte(arg >> 24);
    SD_SPI_ReadWriteByte(arg >> 16);
    SD_SPI_ReadWriteByte(arg >> 8);
    SD_SPI_ReadWriteByte(arg);
    SD_SPI_ReadWriteByte(crc);
    
    if(cmd == CMD12) SD_SPI_ReadWriteByte(0xFF);
    
    retry = 0x1F;
    do {
        r1 = SD_SPI_ReadWriteByte(0xFF);
    } while((r1 & 0x80) && retry--);
    
    return r1;
}

/* SD卡初始化 */
uint8_t SD_Init(void)
{
    uint8_t r1;
    uint16_t retry;
    uint8_t buf[4];
    
    SD_SPI_SetSpeed(0);  // 低速模式
    
    SD_CS_HIGH();
    for(int i = 0; i < 10; i++) {
        SD_SPI_ReadWriteByte(0xFF);  // 发送至少74个时钟
    }
    
    retry = 20;
    do {
        r1 = SD_SendCmd(CMD0, 0, 0x95);
    } while((r1 != 0x01) && retry--);
    
    if(r1 == 0x01) {
        if(SD_SendCmd(CMD8, 0x1AA, 0x87) == 1) {
            for(int i = 0; i < 4; i++) {
                buf[i] = SD_SPI_ReadWriteByte(0xFF);
            }
            if(buf[2] == 0x01 && buf[3] == 0xAA) {
                retry = 0xFFFE;
                do {
                    SD_SendCmd(CMD55, 0, 0x01);
                    r1 = SD_SendCmd(CMD41, 0x40000000, 0x01);
                } while(r1 && retry--);
                
                if(retry && SD_SendCmd(CMD58, 0, 0x01) == 0) {
                    for(int i = 0; i < 4; i++) {
                        buf[i] = SD_SPI_ReadWriteByte(0xFF);
                    }
                    if(buf[0] & 0x40) {
                        SD_Type = SD_TYPE_V2HC;
                    } else {
                        SD_Type = SD_TYPE_V2;
                    }
                }
            }
        } else {
            SD_SendCmd(CMD55, 0, 0x01);
            r1 = SD_SendCmd(CMD41, 0, 0x01);
            if(r1 <= 1) {
                SD_Type = SD_TYPE_V1;
                retry = 0xFFFE;
                do {
                    SD_SendCmd(CMD55, 0, 0x01);
                    r1 = SD_SendCmd(CMD41, 0, 0x01);
                } while(r1 && retry--);
            } else {
                SD_Type = SD_TYPE_MMC;
                retry = 0xFFFE;
                do {
                    r1 = SD_SendCmd(CMD1, 0, 0x01);
                } while(r1 && retry--);
            }
            if(retry == 0 || SD_SendCmd(CMD16, 512, 0x01) != 0) {
                SD_Type = SD_TYPE_ERR;
            }
        }
    }
    
    SD_CS_HIGH();
    SD_SPI_SetSpeed(1);  // 高速模式
    
    if(SD_Type) return 0;
    return 1;
}

/* 读取指定扇区 */
uint8_t SD_ReadDisk(uint8_t *buf, uint32_t sector, uint8_t cnt)
{
    uint8_t r1;
    
    if(SD_Type != SD_TYPE_V2HC) sector <<= 9;
    
    if(cnt == 1) {
        r1 = SD_SendCmd(CMD17, sector, 0x01);
        if(r1 == 0) {
            uint16_t retry = 0xFFFE;
            do {
                r1 = SD_SPI_ReadWriteByte(0xFF);
                if(r1 == 0xFE) break;
            } while(retry--);
            
            if(r1 == 0xFE) {
                for(int i = 0; i < 512; i++) {
                    buf[i] = SD_SPI_ReadWriteByte(0xFF);
                }
                SD_SPI_ReadWriteByte(0xFF);
                SD_SPI_ReadWriteByte(0xFF);
                r1 = 0;
            } else {
                r1 = 1;
            }
        }
    } else {
        r1 = SD_SendCmd(CMD18, sector, 0x01);
        if(r1 == 0) {
            do {
                uint16_t retry = 0xFFFE;
                do {
                    r1 = SD_SPI_ReadWriteByte(0xFF);
                    if(r1 == 0xFE) break;
                } while(retry--);
                
                if(r1 != 0xFE) break;
                
                for(int i = 0; i < 512; i++) {
                    *buf++ = SD_SPI_ReadWriteByte(0xFF);
                }
                SD_SPI_ReadWriteByte(0xFF);
                SD_SPI_ReadWriteByte(0xFF);
            } while(--cnt);
            SD_SendCmd(CMD12, 0, 0x01);
        }
        r1 = cnt ? 1 : 0;
    }
    
    SD_CS_HIGH();
    return r1;
}

/* 写入指定扇区 */
uint8_t SD_WriteDisk(uint8_t *buf, uint32_t sector, uint8_t cnt)
{
    uint8_t r1;
    
    if(SD_Type != SD_TYPE_V2HC) sector <<= 9;
    
    if(cnt == 1) {
        r1 = SD_SendCmd(CMD24, sector, 0x01);
        if(r1 == 0) {
            if(SD_WaitReady() == 0) {
                SD_SPI_ReadWriteByte(0xFE);
                for(int i = 0; i < 512; i++) {
                    SD_SPI_ReadWriteByte(buf[i]);
                }
                SD_SPI_ReadWriteByte(0xFF);
                SD_SPI_ReadWriteByte(0xFF);
                
                r1 = SD_SPI_ReadWriteByte(0xFF);
                if((r1 & 0x1F) == 0x05) {
                    r1 = 0;
                    uint32_t retry = 0xFFFFFF;
                    while(SD_SPI_ReadWriteByte(0xFF) == 0 && retry--);
                    if(retry == 0) r1 = 1;
                } else {
                    r1 = 1;
                }
            } else {
                r1 = 1;
            }
        }
    } else {
        if(SD_Type != SD_TYPE_MMC) {
            SD_SendCmd(CMD55, 0, 0x01);
            SD_SendCmd(CMD23, cnt, 0x01);
        }
        r1 = SD_SendCmd(CMD25, sector, 0x01);
        if(r1 == 0) {
            do {
                if(SD_WaitReady()) { r1 = 1; break; }
                SD_SPI_ReadWriteByte(0xFC);
                for(int i = 0; i < 512; i++) {
                    SD_SPI_ReadWriteByte(*buf++);
                }
                SD_SPI_ReadWriteByte(0xFF);
                SD_SPI_ReadWriteByte(0xFF);
                
                r1 = SD_SPI_ReadWriteByte(0xFF);
                if((r1 & 0x1F) != 0x05) { r1 = 1; break; }
            } while(--cnt);
            
            SD_SPI_ReadWriteByte(0xFD);
            r1 = cnt ? 1 : 0;
        }
    }
    
    SD_CS_HIGH();
    return r1;
}

/* 获取扇区数量 */
uint32_t SD_GetSectorCount(void)
{
    uint8_t csd[16];
    uint32_t capacity;
    uint8_t n;
    uint16_t csize;
    
    if(SD_SendCmd(CMD9, 0, 0x01) == 0) {
        uint16_t retry = 0xFFFE;
        while(SD_SPI_ReadWriteByte(0xFF) != 0xFE && retry--);
        
        if(retry) {
            for(int i = 0; i < 16; i++) {
                csd[i] = SD_SPI_ReadWriteByte(0xFF);
            }
            SD_SPI_ReadWriteByte(0xFF);
            SD_SPI_ReadWriteByte(0xFF);
            
            if((csd[0] & 0xC0) == 0x40) {  // V2.0
                csize = csd[9] + ((uint16_t)csd[8] << 8) + ((uint32_t)(csd[7] & 0x3F) << 16) + 1;
                capacity = csize << 10;
            } else {  // V1.0
                n = (csd[5] & 0x0F) + ((csd[10] & 0x80) >> 7) + ((csd[9] & 0x03) << 1) + 2;
                csize = (csd[8] >> 6) + ((uint16_t)csd[7] << 2) + ((uint16_t)(csd[6] & 0x03) << 10) + 1;
                capacity = (uint32_t)csize << (n - 9);
            }
            SD_CS_HIGH();
            return capacity;
        }
    }
    SD_CS_HIGH();
    return 0;
}

```

#### 3.3 user_diskio.c

```c
/* USER CODE BEGIN Header */
/**
 ******************************************************************************
  * @file    user_diskio.c
  * @brief   This file includes a diskio driver skeleton to be completed by the user.
  ******************************************************************************
  * @attention
  *
  * Copyright (c) 2026 STMicroelectronics.
  * All rights reserved.
  *
  * This software is licensed under terms that can be found in the LICENSE file
  * in the root directory of this software component.
  * If no LICENSE file comes with this software, it is provided AS-IS.
  *
  ******************************************************************************
  */
 /* USER CODE END Header */

#ifdef USE_OBSOLETE_USER_CODE_SECTION_0
/*
 * Warning: the user section 0 is no more in use (starting from CubeMx version 4.16.0)
 * To be suppressed in the future.
 * Kept to ensure backward compatibility with previous CubeMx versions when
 * migrating projects.
 * User code previously added there should be copied in the new user sections before
 * the section contents can be deleted.
 */
/* USER CODE BEGIN 0 */
/* USER CODE END 0 */
#endif

/* USER CODE BEGIN DECL */

/* Includes ------------------------------------------------------------------*/
#include <string.h>
#include "ff_gen_drv.h"


#include "sd_spi.h"
/* Private typedef -----------------------------------------------------------*/
/* Private define ------------------------------------------------------------*/

/* Private variables ---------------------------------------------------------*/
/* Disk status */
static volatile DSTATUS Stat = STA_NOINIT;

/* USER CODE END DECL */

/* Private function prototypes -----------------------------------------------*/
DSTATUS USER_initialize (BYTE pdrv);
DSTATUS USER_status (BYTE pdrv);
DRESULT USER_read (BYTE pdrv, BYTE *buff, DWORD sector, UINT count);
#if _USE_WRITE == 1
  DRESULT USER_write (BYTE pdrv, const BYTE *buff, DWORD sector, UINT count);
#endif /* _USE_WRITE == 1 */
#if _USE_IOCTL == 1
  DRESULT USER_ioctl (BYTE pdrv, BYTE cmd, void *buff);
#endif /* _USE_IOCTL == 1 */

Diskio_drvTypeDef  USER_Driver =
{
  USER_initialize,
  USER_status,
  USER_read,
#if  _USE_WRITE
  USER_write,
#endif  /* _USE_WRITE == 1 */
#if  _USE_IOCTL == 1
  USER_ioctl,
#endif /* _USE_IOCTL == 1 */
};

/* Private functions ---------------------------------------------------------*/

/**
  * @brief  Initializes a Drive
  * @param  pdrv: Physical drive number (0..)
  * @retval DSTATUS: Operation status
  */
DSTATUS USER_initialize (
	BYTE pdrv           /* Physical drive nmuber to identify the drive */
)
{
  /* USER CODE BEGIN INIT */
//    Stat = STA_NOINIT;
//    return Stat;
		uint8_t res;
    res = SD_Init();
    if(res == 0) {
        Stat &= ~STA_NOINIT;
    } else {
        Stat = STA_NOINIT;
    }
    return Stat;
  /* USER CODE END INIT */
}

/**
  * @brief  Gets Disk Status
  * @param  pdrv: Physical drive number (0..)
  * @retval DSTATUS: Operation status
  */
DSTATUS USER_status (
	BYTE pdrv       /* Physical drive number to identify the drive */
)
{
  /* USER CODE BEGIN STATUS */
//    Stat = STA_NOINIT;
//    return Stat;
		return Stat;
  /* USER CODE END STATUS */
}

/**
  * @brief  Reads Sector(s)
  * @param  pdrv: Physical drive number (0..)
  * @param  *buff: Data buffer to store read data
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT USER_read (
	BYTE pdrv,      /* Physical drive nmuber to identify the drive */
	BYTE *buff,     /* Data buffer to store read data */
	DWORD sector,   /* Sector address in LBA */
	UINT count      /* Number of sectors to read */
)
{
  /* USER CODE BEGIN READ */
//    return RES_OK;
    uint8_t res;
    res = SD_ReadDisk(buff, sector, count);
    if(res == 0) {
        return RES_OK;
    }
    return RES_ERROR;
  /* USER CODE END READ */
}

/**
  * @brief  Writes Sector(s)
  * @param  pdrv: Physical drive number (0..)
  * @param  *buff: Data to be written
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to write (1..128)
  * @retval DRESULT: Operation result
  */
#if _USE_WRITE == 1
DRESULT USER_write (
	BYTE pdrv,          /* Physical drive nmuber to identify the drive */
	const BYTE *buff,   /* Data to be written */
	DWORD sector,       /* Sector address in LBA */
	UINT count          /* Number of sectors to write */
)
{
  /* USER CODE BEGIN WRITE */
  /* USER CODE HERE */
//    return RES_OK;
    uint8_t res;
    res = SD_WriteDisk((uint8_t *)buff, sector, count);
    if(res == 0) {
        return RES_OK;
    }
    return RES_ERROR;
  /* USER CODE END WRITE */
}
#endif /* _USE_WRITE == 1 */

/**
  * @brief  I/O control operation
  * @param  pdrv: Physical drive number (0..)
  * @param  cmd: Control code
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT USER_ioctl (
	BYTE pdrv,      /* Physical drive nmuber (0..) */
	BYTE cmd,       /* Control code */
	void *buff      /* Buffer to send/receive control data */
)
{
  /* USER CODE BEGIN IOCTL */
//    DRESULT res = RES_ERROR;
//    return res;
    DRESULT res = RES_ERROR;
    
    switch(cmd) {
        case CTRL_SYNC:
            res = RES_OK;
            break;
        case GET_SECTOR_COUNT:
            *(DWORD *)buff = SD_GetSectorCount();
            res = RES_OK;
            break;
        case GET_SECTOR_SIZE:
            *(WORD *)buff = 512;
            res = RES_OK;
            break;
        case GET_BLOCK_SIZE:
            *(DWORD *)buff = 8;
            res = RES_OK;
            break;
        default:
            res = RES_PARERR;
            break;
    }
    return res;
  /* USER CODE END IOCTL */
}
#endif /* _USE_IOCTL == 1 */


```



#### 3.4 uart_driver.h

```c
#ifndef __UART_DRIVER_H
#define __UART_DRIVER_H

#include "main.h"
#include "usart.h"
#include "dma.h"
#include <stdarg.h>
#include <string.h>
#include <stdio.h>

#define UART_DMA_RX_BUFFER_SIZE     512
#define UART_DATA_BUFFER_SIZE       1024
#define UART_TX_BUFFER_SIZE         256
#define CMD_NEW_FILE                "$new"

typedef enum {
    RX_TYPE_NONE = 0,
    RX_TYPE_CMD_NEW,
    RX_TYPE_DATA
} RxDataType_t;

typedef struct {
    uint8_t     dma_rx_buffer[UART_DMA_RX_BUFFER_SIZE];
    uint8_t     data_buffer[UART_DATA_BUFFER_SIZE];
    char        tx_buffer[UART_TX_BUFFER_SIZE];
    volatile uint16_t   data_len;
    volatile uint8_t    rx_complete;
    RxDataType_t        rx_type;
    UART_HandleTypeDef  *huart;
    DMA_HandleTypeDef   *hdma_rx;
} UART_Driver_t;

extern UART_Driver_t uart1_driver;

void UART_Driver_Init(UART_Driver_t *driver, UART_HandleTypeDef *huart, DMA_HandleTypeDef *hdma_rx);
void UART_Driver_StartReceive(UART_Driver_t *driver);
void UART_Driver_IDLE_Handler(UART_Driver_t *driver);
uint8_t UART_Driver_IsRxComplete(UART_Driver_t *driver);
RxDataType_t UART_Driver_GetRxType(UART_Driver_t *driver);
void UART_Driver_GetData(UART_Driver_t *driver, uint8_t **data, uint16_t *len);
void UART_Driver_ClearRxFlag(UART_Driver_t *driver);
void UART_Driver_Printf(UART_Driver_t *driver, const char *format, ...);

#endif

```

#### 3.5 uart_driver.c

```c
#include "uart_driver.h"

UART_Driver_t uart1_driver;

static RxDataType_t Parse_RxData(uint8_t *data, uint16_t len)
{
    if(len >= strlen(CMD_NEW_FILE)) {
        if(strncmp((char *)data, CMD_NEW_FILE, strlen(CMD_NEW_FILE)) == 0) {
            return RX_TYPE_CMD_NEW;
        }
    }
    return RX_TYPE_DATA;
}

void UART_Driver_Init(UART_Driver_t *driver, UART_HandleTypeDef *huart, DMA_HandleTypeDef *hdma_rx)
{
    driver->huart = huart;
    driver->hdma_rx = hdma_rx;
    memset(driver->dma_rx_buffer, 0, UART_DMA_RX_BUFFER_SIZE);
    memset(driver->data_buffer, 0, UART_DATA_BUFFER_SIZE);
    driver->data_len = 0;
    driver->rx_complete = 0;
    driver->rx_type = RX_TYPE_NONE;
}

void UART_Driver_StartReceive(UART_Driver_t *driver)
{
    __HAL_UART_CLEAR_IDLEFLAG(driver->huart);
    __HAL_UART_ENABLE_IT(driver->huart, UART_IT_IDLE);
    HAL_UART_Receive_DMA(driver->huart, driver->dma_rx_buffer, UART_DMA_RX_BUFFER_SIZE);
}

void UART_Driver_IDLE_Handler(UART_Driver_t *driver)
{
    uint16_t recv_len;
    
    if(__HAL_UART_GET_FLAG(driver->huart, UART_FLAG_IDLE) != RESET)
    {
        __HAL_UART_CLEAR_IDLEFLAG(driver->huart);
        HAL_UART_DMAStop(driver->huart);
        
        recv_len = UART_DMA_RX_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(driver->hdma_rx);
        
        if(recv_len > 0 && recv_len <= UART_DATA_BUFFER_SIZE)
        {
            memcpy(driver->data_buffer, driver->dma_rx_buffer, recv_len);
            driver->data_len = recv_len;
            driver->rx_type = Parse_RxData(driver->data_buffer, recv_len);
            driver->rx_complete = 1;
        }
        
        memset(driver->dma_rx_buffer, 0, UART_DMA_RX_BUFFER_SIZE);
        HAL_UART_Receive_DMA(driver->huart, driver->dma_rx_buffer, UART_DMA_RX_BUFFER_SIZE);
    }
}

uint8_t UART_Driver_IsRxComplete(UART_Driver_t *driver) { return driver->rx_complete; }
RxDataType_t UART_Driver_GetRxType(UART_Driver_t *driver) { return driver->rx_type; }

void UART_Driver_GetData(UART_Driver_t *driver, uint8_t **data, uint16_t *len)
{
    *data = driver->data_buffer;
    *len = driver->data_len;
}

void UART_Driver_ClearRxFlag(UART_Driver_t *driver)
{
    driver->rx_complete = 0;
    driver->data_len = 0;
    driver->rx_type = RX_TYPE_NONE;
}

void UART_Driver_Printf(UART_Driver_t *driver, const char *format, ...)
{
    uint16_t len;
    va_list args;
    va_start(args, format);
    len = vsprintf(driver->tx_buffer, format, args);
    va_end(args);
    HAL_UART_Transmit(driver->huart, (uint8_t *)driver->tx_buffer, len, 1000);
}

```

#### 3.6 sd_logger.h

```c
#ifndef __SD_LOGGER_H
#define __SD_LOGGER_H

#include "main.h"
#include "fatfs.h"
#include <string.h>
#include <stdio.h>

#define FILE_NAME_PREFIX        "data"
#define FILE_NAME_EXTENSION     ".txt"
#define FILE_INDEX_MAX          99
#define SYNC_AFTER_BYTES        512

typedef enum {
    LOGGER_IDLE = 0,
    LOGGER_RECORDING
} LoggerState_t;

typedef struct {
    FATFS       fs;
    FIL         file;
    char        filename[32];
    uint8_t     file_index;
    LoggerState_t state;
    uint8_t     sd_mounted;
    uint32_t    total_bytes;
    uint32_t    unsync_bytes;
} SD_Logger_t;

extern SD_Logger_t sd_logger;

uint8_t SD_Logger_Init(void);
uint8_t SD_Logger_NewFile(void);
uint16_t SD_Logger_WriteData(uint8_t *data, uint16_t len);
uint8_t SD_Logger_Sync(void);
LoggerState_t SD_Logger_GetState(void);
const char* SD_Logger_GetFilename(void);
uint8_t SD_Logger_GetFileIndex(void);
uint32_t SD_Logger_GetTotalBytes(void);

#endif

```

#### 3.7 sd_logger.c

```c
#include "sd_logger.h"

SD_Logger_t sd_logger;

static void Generate_Filename(uint8_t index, char *filename)
{
    sprintf(filename, "%s%02d%s", FILE_NAME_PREFIX, index, FILE_NAME_EXTENSION);
}

static uint8_t File_Exists(const char *filename)
{
    FILINFO fno;
    return (f_stat(filename, &fno) == FR_OK) ? 1 : 0;
}

static uint8_t Find_Next_FileIndex(void)
{
    char filename[32];
    for(uint8_t i = 0; i <= FILE_INDEX_MAX; i++) {
        Generate_Filename(i, filename);
        if(!File_Exists(filename)) return i;
    }
    return 0;
}

uint8_t SD_Logger_Init(void)
{
    FRESULT fres;
    memset(&sd_logger, 0, sizeof(SD_Logger_t));
    
    fres = f_mount(&sd_logger.fs, "", 1);
    if(fres != FR_OK) return (uint8_t)fres;
    
    sd_logger.sd_mounted = 1;
    sd_logger.file_index = Find_Next_FileIndex();
    return 0;
}

uint8_t SD_Logger_NewFile(void)
{
    FRESULT fres;
    if(!sd_logger.sd_mounted) return 1;
    
    /* 关闭旧文件 */
    if(sd_logger.state == LOGGER_RECORDING) {
        f_sync(&sd_logger.file);
        f_close(&sd_logger.file);
    }
    
    /* 创建新文件 */
    Generate_Filename(sd_logger.file_index, sd_logger.filename);
    fres = f_open(&sd_logger.file, sd_logger.filename, FA_CREATE_ALWAYS | FA_WRITE);
    if(fres != FR_OK) return (uint8_t)fres;
    
    sd_logger.state = LOGGER_RECORDING;
    sd_logger.total_bytes = 0;
    sd_logger.unsync_bytes = 0;
    
    sd_logger.file_index++;
    if(sd_logger.file_index > FILE_INDEX_MAX) sd_logger.file_index = 0;
    
    return 0;
}

uint16_t SD_Logger_WriteData(uint8_t *data, uint16_t len)
{
    UINT bw = 0;
    if(sd_logger.state != LOGGER_RECORDING) return 0;
    
    if(f_write(&sd_logger.file, data, len, &bw) != FR_OK) return 0;
    
    sd_logger.total_bytes += bw;
    sd_logger.unsync_bytes += bw;
    
    /* 自动同步保护 */
    if(sd_logger.unsync_bytes >= SYNC_AFTER_BYTES) {
        f_sync(&sd_logger.file);
        sd_logger.unsync_bytes = 0;
    }
    
    return (uint16_t)bw;
}

uint8_t SD_Logger_Sync(void)
{
    if(sd_logger.state != LOGGER_RECORDING) return 0;
    sd_logger.unsync_bytes = 0;
    return (uint8_t)f_sync(&sd_logger.file);
}

LoggerState_t SD_Logger_GetState(void) { return sd_logger.state; }
const char* SD_Logger_GetFilename(void) { return sd_logger.filename; }
uint8_t SD_Logger_GetFileIndex(void) { return sd_logger.file_index; }
uint32_t SD_Logger_GetTotalBytes(void) { return sd_logger.total_bytes; }

```

#### 3.8 main.c

```c
#include "main.h"
#include "dma.h"
#include "fatfs.h"
#include "spi.h"
#include "tim.h"
#include "usart.h"
#include "gpio.h"
#include "uart_driver.h"
#include "sd_logger.h"

volatile uint8_t tim2_flag = 0;
volatile uint16_t tim2_counter = 0;

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_DMA_Init();
    MX_SPI1_Init();
    MX_TIM2_Init();
    MX_USART1_UART_Init();
    MX_FATFS_Init();
    
    UART_Driver_Init(&uart1_driver, &huart1, &hdma_usart1_rx);
    
    if(SD_Logger_Init() == 0) {
        UART_Driver_Printf(&uart1_driver, "SD Ready! Next: data%02d.txt\r\n", SD_Logger_GetFileIndex());
    }
    
    UART_Driver_StartReceive(&uart1_driver);
    HAL_TIM_Base_Start_IT(&htim2);
    
    UART_Driver_Printf(&uart1_driver, "Send '$new' to start recording\r\n");
    
    while(1)
    {
        /* 定时任务 */
        if(tim2_flag)
        {
            tim2_flag = 0;
            
            if(tim2_counter % 100 == 0) {  /* 1秒 */
                HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
            }
            
            if(tim2_counter % 200 == 0) {  /* 2秒同步 */
                if(SD_Logger_GetState() == LOGGER_RECORDING) {
                    SD_Logger_Sync();
                }
            }
            
            if(tim2_counter >= 10000) tim2_counter = 0;
            tim2_counter++;
        }
        
        /* 串口处理 */
        if(UART_Driver_IsRxComplete(&uart1_driver))
        {
            RxDataType_t rx_type = UART_Driver_GetRxType(&uart1_driver);
            
            if(rx_type == RX_TYPE_CMD_NEW) {
                if(SD_Logger_NewFile() == 0) {
                    UART_Driver_Printf(&uart1_driver, "Created: %s\r\n", SD_Logger_GetFilename());
                }
            }
            else if(rx_type == RX_TYPE_DATA) {
                if(SD_Logger_GetState() == LOGGER_RECORDING) {
                    uint8_t *data; uint16_t len;
                    UART_Driver_GetData(&uart1_driver, &data, &len);
                    SD_Logger_WriteData(data, len);
                }
            }
            
            UART_Driver_ClearRxFlag(&uart1_driver);
        }
    }
}

void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
{
    if(htim->Instance == TIM2) tim2_flag = 1;
}

```

#### 3.9 stm32f1xx_it.c（中断部分）

```c
#include "uart_driver.h"

void USART1_IRQHandler(void)
{
    UART_Driver_IDLE_Handler(&uart1_driver);
    HAL_UART_IRQHandler(&huart1);
}

```

### 四、断电保护机制

```
┌─────────────────────────────────────────┐
│           双重保护                       │
├─────────────────────────────────────────┤
│ 1. 写入保护: 每512字节自动同步           │
│ 2. 定时保护: 每2秒强制同步               │
├─────────────────────────────────────────┤
│ 断电最大损失: ≤512字节                   │
│ 文件系统风险: 低                         │
└─────────────────────────────────────────┘
```

### 五、使用流程

```
上电 → SD卡初始化 → 等待命令
         ↓
发送 "$new" → 创建 data00.txt → 记录数据
         ↓
发送 "$new" → 关闭旧文件 → 创建 data01.txt
         ↓
      依次递增...
```

### 六、串口测试

```
SD Ready! Next: data00.txt
Send '$new' to start recording

> $new
Created: data00.txt

> Hello World
(数据写入SD卡)

> $new
Created: data01.txt
```

### 七、CubeMX配置要点

|  外设  |               配置               |
| :----: | :------------------------------: |
|  SPI1  | Full-Duplex Master, 分频后≤18MHz |
| USART1 |          115200, DMA RX          |
|  TIM2  |        10ms周期, 开启中断        |
| FATFS  |           User-defined           |





